<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Mascarilla profesional (fix)</title>
<style>
  :root{--accent:#00f5d4}
  body{margin:0;background:#07070a;font-family:Inter,system-ui,Roboto,Arial;color:#e6eef8;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh}
  .container{width:100%;max-width:1100px;height:80vh;position:relative;border-radius:12px;overflow:hidden;background:#000}
  video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1)} /* espejo */
  canvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}
  .controls{position:absolute;left:12px;top:12px;z-index:30;background:rgba(0,0,0,0.45);padding:10px;border-radius:10px;backdrop-filter:blur(6px);display:flex;gap:8px;align-items:center}
  button{padding:.6rem .9rem;border-radius:8px;border:0;background:#2563eb;color:#fff;font-weight:700;cursor:pointer}
  button.secondary{background:#374151}
  .status{position:absolute;right:12px;top:12px;color:var(--accent);font-weight:700;background:rgba(0,0,0,0.4);padding:8px 10px;border-radius:8px}
  .small{font-size:13px;color:#9aa7b3}
  @media (max-width:700px){ .controls{left:8px;top:8px;padding:8px} .status{right:8px;top:8px} }
</style>

<!-- MediaPipe FaceMesh -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
</head>
<body>
  <div class="container" id="stage" role="application">
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>

    <div class="controls" role="toolbar" aria-label="Controles">
      <button id="startBtn">Iniciar cámara</button>
      <button id="stopBtn" class="secondary" disabled>Detener</button>
      <div class="small" id="note">Estado: <span id="statText">inactivo</span></div>
    </div>

    <div class="status" id="status">Listo</div>
  </div>

<script>
(async function(){
  // --- CONFIG ---
  const MASK_PNG = 'https://raw.githubusercontent.com/johndcobb/mediapipe-facemesh-mask-assets/main/masks/surgical_blue.png';
  // Anchors we will use: left cheek (234), right cheek (454), nose tip (1), chin (152)
  const IDX = { leftCheek:234, rightCheek:454, nose:1, chin:152 };

  // DOM
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d', { alpha: true });
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const status = document.getElementById('status');
  const statText = document.getElementById('statText');

  // state
  let camera = null;
  let faceMesh = null;
  let running = false;
  let dpr = window.devicePixelRatio || 1;
  let prevSmoothed = null;
  const SMOOTH = 0.6; // 0..1 lower = less smoothing

  // load mask image
  const maskImg = new Image();
  maskImg.crossOrigin = 'anonymous';
  maskImg.src = MASK_PNG;
  let maskReady = false;
  maskImg.onload = () => { maskReady = true; console.log('Mask loaded'); };

  // helpers
  const lerp = (a,b,t) => a + (b-a)*t;

  function resizeCanvasToVideo(){
    const vw = video.videoWidth || video.clientWidth || 640;
    const vh = video.videoHeight || video.clientHeight || 480;
    dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(vw * dpr);
    canvas.height = Math.round(vh * dpr);
    canvas.style.width = `${vw}px`;
    canvas.style.height = `${vh}px`;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // Smooth landmarks temporally
  function smoothLandmarks(prev, curr){
    if (!prev || prev.length !== curr.length) {
      return curr.map(p => ({ x:p.x, y:p.y, z:p.z || 0 }));
    }
    const out = [];
    for (let i=0;i<curr.length;i++){
      out.push({
        x: lerp(curr[i].x, prev[i].x, SMOOTH),
        y: lerp(curr[i].y, prev[i].y, SMOOTH),
        z: lerp(curr[i].z||0, prev[i].z||0, SMOOTH)
      });
    }
    return out;
  }

  // Set up FaceMesh
  faceMesh = new FaceMesh({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });
  faceMesh.setOptions({
    maxNumFaces: 1,
    refineLandmarks: true,
    selfieMode: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  faceMesh.onResults(onResults);

  // Camera helper
  function startCamera(){
    statText.textContent = 'solicitando permiso...';
    startBtn.disabled = true;
    // choose moderate resolution for mobile+desktop
    camera = new Camera(video, {
      onFrame: async () => { await faceMesh.send({ image: video }); },
      width: 960,
      height: 720,
      facingMode: 'user'
    });
    camera.start().then(() => {
      running = true;
      stopBtn.disabled = false;
      statText.textContent = 'cámara activa';
      status.textContent = 'Cámara activa';
      // ensure canvas size set
      video.addEventListener('loadedmetadata', ()=> resizeCanvasToVideo(), { once: true });
    }).catch(err => {
      console.error('camera start error', err);
      startBtn.disabled = false;
      statText.textContent = 'error: ' + (err?.message || err);
      status.textContent = 'No se pudo iniciar la cámara';
    });
  }

  function stopCamera(){
    if (camera) { camera.stop(); camera = null; }
    running = false;
    stopBtn.disabled = true;
    startBtn.disabled = false;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    status.textContent = 'Cámara detenida';
    statText.textContent = 'detenida';
  }

  function drawHUDText(){
    ctx.save();
    ctx.font = '12px Inter, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillText('Mascarilla AR — profesional', 12, 18);
    ctx.restore();
  }

  // Main rendering when faceMesh produces results
  function onResults(results){
    resizeCanvasToVideo();
    ctx.clearRect(0,0,canvas.width/dpr, canvas.height/dpr);
    // mirror canvas to match video
    ctx.save();
    ctx.translate(canvas.width / dpr, 0);
    ctx.scale(-1, 1);

    if (!results || !results.multiFaceLandmarks || !results.multiFaceLandmarks.length) {
      status.textContent = 'Esperando rostro…';
      // still draw HUD
      drawHUDText();
      ctx.restore();
      return;
    }

    status.textContent = 'Rostro detectado';
    const raw = results.multiFaceLandmarks[0]; // normalized (x,y,z)
    const W = canvas.width / dpr;
    const H = canvas.height / dpr;

    // convert normalized to px
    const curr = raw.map(p => ({ x: p.x * W, y: p.y * H, z: (p.z || 0) * W }));
    const smooth = smoothLandmarks(prevSmoothed, curr);
    prevSmoothed = smooth;

    // Draw light mesh but only on important regions (reduced visual noise)
    // We'll draw a thin, subtle wire around face contour + nose bridge + mouth contour
    ctx.lineWidth = 0.9;
    ctx.strokeStyle = 'rgba(14,165,233,0.85)'; // cyan
    ctx.shadowColor = 'rgba(14,165,233,0.25)';
    ctx.shadowBlur = 6;

    // jaw outline indices 0..16
    const jaw = []; for (let i=0;i<=16;i++) jaw.push(smooth[i]);
    // draw jaw curve
    ctx.beginPath();
    jaw.forEach((p,i)=> { if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
    ctx.stroke();

    // nose bridge (indices 1,2,3,4)
    const noseBridgeIdx = [1,2,3,4];
    ctx.beginPath();
    noseBridgeIdx.forEach((idx,i)=> { const p = smooth[idx]; if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
    ctx.stroke();

    // mouth outer (48..60)
    const mouthOuter = []; for (let i=48;i<=59;i++) mouthOuter.push(smooth[i]);
    ctx.beginPath();
    mouthOuter.forEach((p,i)=> { if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
    ctx.closePath();
    ctx.stroke();

    // subtle points only at key landmarks (reduced)
    const keyIdx = [1, 4, 9, 33, 263, 57, 287, 152]; // nose, top forehead, chin, eye corners, mouth
    ctx.fillStyle = 'rgba(0,245,212,0.95)';
    for (const i of keyIdx){
      const p = smooth[i];
      if (!p) continue;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2);
      ctx.fill();
    }

    // NOW: draw mask image mapped using anchors
    // anchors: left cheek (234), right cheek (454), nose tip (1), chin (152)
    const a = smooth[IDX.leftCheek];
    const b = smooth[IDX.rightCheek];
    const n = smooth[IDX.nose];
    const c = smooth[IDX.chin];

    if (a && b && n && c && maskReady) {
      // compute center between cheeks
      const cx = (a.x + b.x) / 2;
      // width approx distance between cheeks
      const faceW = Math.hypot(b.x - a.x, b.y - a.y);
      // height approx nose->chin
      const faceH = Math.hypot(c.x - n.x, c.y - n.y);
      // rotation angle
      const angle = Math.atan2(b.y - a.y, b.x - a.x);

      // mask scale tweaks for better fit
      const maskW = faceW * 1.18;   // widen slightly to cover
      const maskH = faceH * 1.45;   // taller to cover nose->chin
      // draw rotated image centered at cx, cy (a bit below nose)
      const cy = n.y + (c.y - n.y) * 0.45;

      // save and apply transform: translate -> rotate -> drawImage centered
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      // optionally fine-tune vertical offset so the mask sits nicely under nose
      const yOffset = -maskH * 0.12;
      ctx.globalAlpha = 1.0;
      // drawImage(image, x, y, width, height) where x,y are top-left relative to transformed origin
      ctx.drawImage(maskImg, -maskW/2, yOffset - maskH/2, maskW, maskH);
      ctx.restore();

      // add soft white border/stitch effect using stroke with low alpha
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2;
      // approximate border: ellipse path
      ctx.beginPath();
      ctx.ellipse(0, yOffset, maskW*0.5, maskH*0.48, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // small smoothing shadow under mask for integration
    if (a && b && n && c) {
      const cx = (a.x + b.x) / 2;
      const faceW = Math.hypot(b.x - a.x, b.y - a.y);
      const faceH = Math.hypot(c.x - n.x, c.y - n.y);
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#000';
      const angle = Math.atan2(b.y - a.y, b.x - a.x);
      ctx.translate(cx, n.y + faceH*0.35);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.ellipse(0, 0, faceW*0.45, faceH*0.18, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // finish HUD text
    drawHUDText();

    ctx.restore(); // restore mirroring flip
  }

  function drawHUDText(){
    ctx.save();
    ctx.font = '13px Inter, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillText('Mascarilla AR — Profesional', 12, 20);
    ctx.restore();
  }

  // button events
  startBtn.addEventListener('click', () => {
    startBtn.disabled = true;
    statText.textContent = 'iniciando...';
    startCamera();
  });
  stopBtn.addEventListener('click', () => stopCamera());

  // expose simple debug
  window.__ar = { faceMesh };

  // initial status
  status.textContent = 'Pulsa "Iniciar cámara"';
  statText.textContent = 'detenido';

})();
</script>
</body>
</html>
